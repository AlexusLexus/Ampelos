// yes


#include "K2Node_QuestUpdate.h"

#include <Ampelos/AmpelosCPPFunctionLibrary.h>

#include "KismetCompiler.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "K2Node_CallFunction.h"
#include "UObject/Class.h"
#include "UObject/Object.h"
#include "BlueprintActionDatabaseRegistrar.h"

#define LOCTEXT_NAMESPACE "K2Node_QuestUpdate"

struct FGetPins
{
	static const FName& GetTestPin() 
	{
		static const FName TestPinName(TEXT("Objective Set"));
		return TestPinName;
	}

	static const FName& GetOutputPin()
	{
		static const FName OutputPinName(TEXT("New Count"));
		return OutputPinName;
	}

};

void UK2Node_QuestUpdate::AllocateDefaultPins()
{

	Super::AllocateDefaultPins();
	const UEdGraphSchema_K2* K2Schema1 = GetDefault<UEdGraphSchema_K2>();

	/*Creating Pins*/

	//Execution pins
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	//Input
	UEdGraphPin* InTestPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, FGetPins::GetTestPin());
	K2Schema1->SetPinAutogeneratedDefaultValue(InTestPin, FString("Quest's Objective Set"));

	//Output
	UEdGraphPin* OutValidPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Int, FGetPins::GetOutputPin());
	K2Schema1->SetPinAutogeneratedDefaultValueBasedOnType(OutValidPin);

}

FText UK2Node_QuestUpdate::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return QuestUpdate_Name;
}

FText UK2Node_QuestUpdate::GetTooltipText() const
{
	return QuestUpdate_Desc;
}

FText UK2Node_QuestUpdate::GetMenuCategory() const
{
	return QuestUpdate_Category;
}

FLinearColor UK2Node_QuestUpdate::GetNodeTitleColor() const
{
	return FLinearColor(70, 120, 90);
}

void UK2Node_QuestUpdate::ExpandNode(FKismetCompilerContext & CompilerContext, UEdGraph * SourceGraph)
{

	ExpandNode(CompilerContext, SourceGraph);

	UFunction* QuestUpdateBlueprintFunction = UAmpelosCPPFunctionLibrary::StaticClass()->FindFunctionByName(FName(TEXT("UpdateQuest")));

	if (QuestUpdateBlueprintFunction != NULL)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("InvalidFunctionName", "No function found.").ToString(), this);
		return;
	}

	UK2Node_CallFunction* CallQuestUpdateFunction = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);

	CallQuestUpdateFunction->SetFromFunction(QuestUpdateBlueprintFunction);
	CallQuestUpdateFunction->AllocateDefaultPins();
	CompilerContext.MessageLog.NotifyIntermediateObjectCreation(CallQuestUpdateFunction, this);

	//Input
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPins::GetTestPin()), *CallQuestUpdateFunction->FindPin(TEXT("Objective Set")));

	//Output
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPins::GetOutputPin()), *CallQuestUpdateFunction->FindPin(TEXT("New Count")));

	//Exec Pins
	UEdGraphPin* NodeExec = GetExecPin();
	UEdGraphPin* NodeThen = FindPin(UEdGraphSchema_K2::PN_Then);

	UEdGraphPin* InternalExec = CallQuestUpdateFunction->GetExecPin();
	CompilerContext.MovePinLinksToIntermediate(*NodeExec, *InternalExec);

	UEdGraphPin* InternalThen = CallQuestUpdateFunction->GetThenPin();
	CompilerContext.MovePinLinksToIntermediate(*NodeThen, *InternalThen);

	BreakAllNodeLinks();

}

UClass * UK2Node_QuestUpdate::GetPinClass()
{
	return nullptr;
}

//void UK2Node_QuestUpdate::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
//{
//	GetMenuActions(ActionRegistrar)
//
//	UClass* K2_Action1 = GetClass();
//
//	if (ActionRegistrar.IsOpenForRegistration(K2_Action1)) 
//	{
//		UBlueprintNodeSpawner* Spawner1 = UBlueprintNodeSpawner::Create(GetClass());
//		check(Spawner1 != nullptr);
//
//		ActionRegistrar.AddBlueprintAction(K2_Action1, Spawner1);
//	}
//}

#undef LOCTEXT_NAMESPACE
